[
  {
    "id": 1,
    "question": "What are Coroutines in Android?",
    "answer": "Coroutines are a concurrency design pattern introduced in Kotlin. They provide a way to write asynchronous and non-blocking code in a sequential and more readable manner.",
    "difficulty": "Easy",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Coroutines",
    "subCategoryId": 1
  },
  {
    "id": 2,
    "question": "What are the main advantages of using Coroutines in Android development?",
    "answer": "Coroutines offer several benefits, such as simplified concurrency, structured concurrency, easy cancellation, built-in support for asynchronous operations, and seamless integration with Kotlin.",
    "difficulty": "Medium",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Coroutines",
    "subCategoryId": 1
  },
  {
    "id": 3,
    "question": "What is the difference between launch() and async() functions in Coroutines?",
    "answer": "The launch() function is used for fire-and-forget style operations, while the async() function is used when you need to obtain a result from the coroutine. The async() function returns a deferred value that can be used to retrieve the result later.",
    "difficulty": "Medium",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Coroutines",
    "subCategoryId": 1
  },
  {
    "id": 4,
    "question": "How can you handle exceptions in Coroutines?",
    "answer": "In Coroutines, you can handle exceptions using try-catch blocks within the coroutine or by using the CoroutineExceptionHandler to handle uncaught exceptions in a centralized manner.",
    "difficulty": "Easy",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Coroutines",
    "subCategoryId": 1
  },
  {
    "id": 5,
    "question": "What is a CoroutineScope in Android?",
    "answer": "A CoroutineScope is an interface provided by the Coroutine library that defines a context for coroutines. It manages the lifecycle of coroutines and provides the necessary functions to launch and manage coroutines within its scope.",
    "difficulty": "Easy",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Coroutines",
    "subCategoryId": 1
  },
  {
    "id": 8,
    "question": "What is Jetpack Compose?",
    "answer": "Jetpack Compose is a modern toolkit for building native Android UI using a declarative approach. It simplifies the UI development process and offers a more efficient way to create dynamic and interactive user interfaces.",
    "difficulty": "Medium",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Compose",
    "subCategoryId": 3
  },
  {
    "id": 9,
    "question": "What are the key benefits of using Jetpack Compose?",
    "answer": "Jetpack Compose provides benefits such as simplified UI development, declarative UI programming model, efficient UI updates with state management, built-in support for theming and animations, and improved testing and debugging capabilities.",
    "difficulty": "Medium",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Compose",
    "subCategoryId": 3
  },
  {
    "id": 15,
    "question": "What does subscribeOn(scheduler) do?",
    "answer": "The `subscribeOn` operator is used on Observables to specify the thread on which Observers should receive the emitted items. It asynchronously subscribes Observers to the ObservableSource on the specified Scheduler.",
    "difficulty": "Medium",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Rx",
    "subCategoryId": 7
  },
  {
    "id": 16,
    "question": "RxJava Operators - Defer",
    "answer": "The `defer` operator delays the creation of an Observable until an Observer subscribes. It ensures that each Observer receives a fresh instance of the Observable.",
    "difficulty": "Easy",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Rx",
    "subCategoryId": 7
  },
  {
    "id": 17,
    "question": "RxJava Operators - Interval",
    "answer": "The `interval` operator creates an Observable that emits a sequence of integers spaced by a specified time interval. It is useful for creating timers, periodic tasks, or scheduling actions.",
    "difficulty": "Medium",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Rx",
    "subCategoryId": 7
  },
  {
    "id": 18,
    "question": "RxJava Operators - Timer",
    "answer": "The `timer` operator creates an Observable that emits a single item after a specified delay. It is useful for triggering actions after a certain period of time.",
    "difficulty": "Easy",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Rx",
    "subCategoryId": 7
  },
  {
    "id": 19,
    "question": "RxJava Operators - Buffer",
    "answer": "The `buffer` operator periodically gathers items emitted by an Observable into bundles and emits these bundles instead of emitting the items one at a time. It is useful for grouping or batching emitted items.",
    "difficulty": "Medium",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Rx",
    "subCategoryId": 7
  },
  {
    "id": 20,
    "question": "RxJava Operators - FlatMap",
    "answer": "The `flatMap` operator transforms the items emitted by an Observable into Observables, then flattens the emissions from those Observables into a single Observable. Note that the order of emissions may not be preserved.",
    "difficulty": "Medium",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Rx",
    "subCategoryId": 7
  },
  {
    "id": 21,
    "question": "RxJava Operators - Scan",
    "answer": "The `scan` operator applies a function to each item emitted by an Observable, sequentially, and emits each intermediate result. It is useful for performing calculations or accumulating values over time.",
    "difficulty": "Medium",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Rx",
    "subCategoryId": 7
  },
  {
    "id": 22,
    "question": "RxJava Operators - Debounce",
    "answer": "The `debounce` operator only emits an item from an Observable if a specified timespan has passed without any subsequent emissions. It is useful for handling events that occur too frequently.",
    "difficulty": "Medium",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Rx",
    "subCategoryId": 7
  },
  {
    "id": 23,
    "question": "RxJava Operators - Distinct",
    "answer": "The `distinct` operator suppresses duplicate items emitted by an Observable, ensuring that only unique items are passed along. It is useful for filtering out repeated values.",
    "difficulty": "Medium",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Rx",
    "subCategoryId": 7
  },
  {
    "id": 24,
    "question": "RxJava Operators - IgnoreElements",
    "answer": "The `ignoreElements` operator does not emit any items from an Observable but mirrors its termination notification. It is useful when you are only interested in the completion or error signal of an Observable.",
    "difficulty": "Easy",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Rx",
    "subCategoryId": 7
  },
  {
    "id": 25,
    "question": "RxJava Operators - Last",
    "answer": "The `last` operator emits only the last item emitted by an Observable, or a default item if the Observable completes without emitting any items. It is useful for retrieving the last value of a sequence.",
    "difficulty": "Easy",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Rx",
    "subCategoryId": 7
  },
  {
    "id": 26,
    "question": "RxJava Operators - Sample",
    "answer": "The `sample` operator emits the most recent item emitted by an Observable within periodic time intervals. It is useful for sampling values at regular intervals or based on external events.",
    "difficulty": "Medium",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Rx",
    "subCategoryId": 7
  },
  {
    "id": 27,
    "question": "RxJava Operators - Take, TakeLast",
    "answer": "The `take` operator emits only the first n items emitted by an Observable, while the `takeLast` operator emits only the last n items emitted by an Observable. They are useful for limiting the number of emitted items.",
    "difficulty": "Easy",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Rx",
    "subCategoryId": 7
  },
  {
    "id": 28,
    "question": "RxJava Operators - CombineLatest",
    "answer": "The `combineLatest` operator combines the emissions of multiple Observables together via a specified function and emits items based on the results of this function. It triggers emissions whenever any of the combined Observables emit an item.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Rx",
    "subCategoryId": 7
  },
  {
    "id": 29,
    "question": "RxJava Operators - Join",
    "answer": "The `join` operator combines items emitted by two Observables whenever an item from one Observable is emitted during a time window defined according to an item emitted by the other Observable. It is useful for handling temporal relationships between items.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Rx",
    "subCategoryId": 7
  },
  {
    "id": 30,
    "question": "RxJava Operators - Merge",
    "answer": "The `merge` operator combines multiple Observables into one by merging their emissions. It interleaves the items emitted by the source Observables, emitting them as they arrive. It is useful for combining concurrent streams of data.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Rx",
    "subCategoryId": 7
  },
  {
    "id": 31,
    "question": "RxJava Operators - StartWith",
    "answer": "The `startWith` operator emits a specified sequence of items before beginning to emit the items from the source Observable. It is useful for prepending initial or default values to an Observable sequence.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Rx",
    "subCategoryId": 7
  },
  {
    "id": 32,
    "question": "RxJava Operators - Switch",
    "answer": "The `switch` operator converts an Observable that emits Observables into a single Observable that emits the items emitted by the most-recently-emitted Observable. It switches to a new Observable whenever a new one is emitted.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Rx",
    "subCategoryId": 7
  },
  {
    "id": 33,
    "question": "RxJava Operators - Zip",
    "answer": "The `zip` operator combines the emissions of multiple Observables together via a specified function and emits single items for each combination based on the results of this function. It emits items only when all combined Observables have emitted an item.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Rx",
    "subCategoryId": 7
  },
  {
    "id": 34,
    "question": "RxJava Operators - ObserveOn",
    "answer": "The `observeOn` operator specifies the scheduler on which an observer will observe the emissions of an Observable. It is useful for specifying the thread or scheduler for consuming or processing emitted items.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Rx",
    "subCategoryId": 7
  },
  {
    "id": 35,
    "question": "RxJava Operators - Subscribe",
    "answer": "The `subscribe` operator allows you to operate upon the emissions and notifications from an Observable. It provides various overloads to specify the actions to be taken on each emitted item, error, or completion signal.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Rx",
    "subCategoryId": 7
  },
  {
    "id": 36,
    "question": "RxJava Operators - Map",
    "answer": "The `map` operator transforms the items emitted by an Observable by applying a function to each item. It allows you to perform a one-to-one transformation of the emitted values.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Rx",
    "subCategoryId": 7
  },
  {
    "id": 37,
    "question": "RxJava Operators - Window",
    "answer": "The `window` operator periodically subdivides items from an Observable into Observable windows and emits these windows instead of emitting the items one at a time. It is useful for grouping or batching emitted items into separate Observables.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Rx",
    "subCategoryId": 7
  },
  {
    "id": 38,
    "question": "Describe StateFlow.",
    "answer": "State flow is a special-purpose, high-performance, and efficient implementation of SharedFlow for the narrow, but widely used case of sharing a state. State flow always has an initial value, replays one most recent value to new subscribers, does not buffer any more values, but keeps the last emitted one, and does not support resetReplayCache. MutableStateFlow(initialValue) is a shared flow with the following parameters: val shared = MutableSharedFlow(replay = 1, onBufferOverflow = BufferOverflow.DROP_OLDEST) shared.tryEmit(initialValue) emit the initial value val state = shared.distinctUntilChanged() get StateFlow-like behavior. A SharedFlow that represents a read-only state with a single updatable data value that emits updates to the value to its collectors. A state flow is a hot flow because its active instance exists independently of the presence of collectors. Its current value can be retrieved via the value property. When a new consumer starts collecting from the flow, it receives the last state in the stream and any subsequent states.",
    "difficulty": "Medium",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "StateAndSharedFlow",
    "subCategoryId": 8
  },
  {
    "id": 39,
    "question": "Describe the differences and similarities between State Flow & Shared Flow.",
    "answer": "StateFlow is a specialized configuration of SharedFlow optimized for sharing state: the last emitted item is replayed to new collectors, and items are conflated using Any.equals. Similarities: - StateFlow & SharedFlow are both hot flows - They are both Flows. Differences: - SharedFlows are used for one-time-events, such as displaying Snackbar or Toasts - StateFlow will automatically emit the value after, for example, device rotates - StateFlow would not re-emit the same value, so i.e., displaying the same Snackbar multiple times would be impossible.",
    "difficulty": "Medium",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "StateAndSharedFlow",
    "subCategoryId": 8
  },
  {
    "id": 40,
    "question": "Describe SharedFlow.",
    "answer": "A hot Flow that shares emitted values among all its collectors in a broadcast fashion so that all collectors get all emitted values. A shared flow is called hot because its active instance exists independently of the presence of collectors. This is opposed to a regular Flow, such as defined by the flow { ... } function, which is cold and is started separately for each collector. SharedFlow is useful for broadcasting events that happen inside an application to subscribers that can come and go. A shared flow keeps a specific number of the most recent values in its replay cache. Every new subscriber first gets the values from the replay cache and then gets new emitted values. The maximum size of the replay cache is specified when the shared flow is created by the replay parameter. A snapshot of the current replay cache is available via the replayCache property, and it can be reset with the MutableSharedFlow.resetReplayCache function. Use SharedFlow when you need a StateFlow with tweaks in its behavior such as extra buffering, replaying more values, or omitting the initial value.",
    "difficulty": "Medium",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "StateAndSharedFlow",
    "subCategoryId": 8
  },
  {
    "id": 41,
    "question": "What is a hot flow? What is a cold flow?",
    "answer": "A cold flow does not start producing values until one starts to collect them. Cold flows are created on-demand and emit data when they’re being observed. On the other hand, a hot flow starts producing values immediately and is always active, even if there are no subscribers/collectors. Hot flows are better for sharing state across multiple observers.",
    "difficulty": "Easy",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "StateAndSharedFlow",
    "subCategoryId": 9
  },
  {
    "id": 42,
    "question": "LiveData vs StateFlow",
    "answer": "LiveData is an Android-only class and is therefore unfit for the domain and data layer. StateFlow, on the other hand, is a Flow, which enables the use of powerful Flow operators and is not limited to the Android platform.",
    "difficulty": "Easy",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "StateAndSharedFlow",
    "subCategoryId": 9
  },
  {
    "id": 43,
    "question": "launchWhenStarted{ }, repeatOnLifecycle {}",
    "answer": "The `launchWhenStarted` function launches and runs the given block when the Lifecycle controlling the LifecycleCoroutineScope is at least in the STARTED state. The returned Job will be cancelled when the Lifecycle is destroyed. However, this API is not recommended to use as it can lead to wasted resources in some cases. It is recommended to use the `Lifecycle.repeatOnLifecycle` API instead, which will be removed in a future release.",
    "difficulty": "Easy",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Coroutines",
    "subCategoryId": 9
  },
  {
    "id": 44,
    "question": "repeatOnLifecycle() {}",
    "answer": "The `repeatOnLifecycle` function launches the block in a new coroutine every time the lifecycle is in the STARTED state or above, and cancels it when it's in the STOPPED state.",
    "difficulty": "Easy",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Coroutines",
    "subCategoryId": 9
  },
  {
    "id": 45,
    "question": "Flow vs StateFlow & LiveData",
    "answer": "Flow does not hold a state. On the other hand, StateFlow and LiveData are both Flow-based implementations that can hold and emit a state. StateFlow is optimized for sharing state with additional features such as replaying the last emitted value, while LiveData is specifically designed for use in Android applications and provides lifecycle-aware behavior.",
    "difficulty": "Easy",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "StateAndSharedFlow",
    "subCategoryId": 8
  },
  {
    "id": 46,
    "question": "shareIn(), stateIn()",
    "answer": "The `shareIn` and `stateIn` operators convert cold flows into hot flows. They multicast the information that comes from a cold upstream flow to multiple collectors. A cold flow is created on-demand and emits data when it's being observed, while a hot flow is always active and can emit data regardless of whether or not it's being observed.",
    "difficulty": "Easy",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "StateAndSharedFlow",
    "subCategoryId": 8
  },
  {
    "id": 48,
    "question": "Compose",
    "answer": "Jetpack Compose is a modern UI toolkit for building native Android UIs. It offers a declarative approach to building user interfaces, where you describe your UI and Compose takes care of the rest. Compose intelligently determines which parts of the UI need to be redrawn at any given time, resulting in efficient UI updates. It simplifies UI development by allowing you to focus on what the UI should look like rather than how to update it in response to state changes. With Compose, you can create dynamic, interactive, and highly customizable UIs with less code compared to traditional Android View-based development.",
    "difficulty": "Easy",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Compose",
    "subCategoryId": 10
  },
  {
    "id": 105,
    "question": "What is an Activity in Android?",
    "answer": "An Activity is a core component in Android that represents a single screen with a user interface. It is a window that contains the UI elements and responds to user interactions. Each Activity is independent and can be launched by an Intent or as part of a task.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Basic",
    "subCategoryId": 11
  },
  {
    "id": 106,
    "question": "What is an Intent in Android?",
    "answer": "An Intent is a messaging object in Android that is used to request an action from another component, such as starting an Activity, broadcasting a message, or invoking a service. It can carry data using extras and can specify the target component explicitly or implicitly based on the action and data.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Basic",
    "subCategoryId": 11
  },
  {
    "id": 107,
    "question": "What is a Fragment in Android?",
    "answer": "A Fragment is a modular section of an Activity that represents a reusable portion of the user interface and behavior. Fragments are used to build flexible and dynamic UI designs that can be combined and reused across multiple Activities. They have their own lifecycle and can be added or replaced within an Activity dynamically.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Basic",
    "subCategoryId": 11
  },
  {
    "id": 108,
    "question": "What is the AndroidManifest.xml file in Android?",
    "answer": "The AndroidManifest.xml file is an essential configuration file in an Android app that provides essential information about the app to the Android system. It contains details such as the app's package name, declared components (Activities, Services, Broadcast Receivers), required permissions, and hardware requirements. It acts as a blueprint for the Android system to understand and interact with the app.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Basic",
    "subCategoryId": 11
  },
  {
    "id": 109,
    "question": "What is Gradle in Android?",
    "answer": "Gradle is a build system in Android used for building and managing the app's dependencies, resources, and configuration. It uses a Groovy or Kotlin-based DSL (Domain-Specific Language) for defining the build scripts. Gradle is highly customizable and allows developers to automate repetitive tasks, handle different build variants, and integrate with external libraries and plugins.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Basic",
    "subCategoryId": 11
  },
  {
    "id": 110,
    "question": "What is a Layout in Android?",
    "answer": "A Layout in Android is a container that holds UI elements and arranges them on the screen. It defines the structure and appearance of the user interface. Android provides various types of layouts, such as LinearLayout, RelativeLayout, ConstraintLayout, and FrameLayout, to organize and position the UI elements in different ways.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Basic",
    "subCategoryId": 11
  },
  {
    "id": 111,
    "question": "What is an Adapter in Android?",
    "answer": "An Adapter is a bridge between the UI components (such as ListView, RecyclerView) and the data source. It provides data to the UI components, creates views for each item, and handles user interactions. Adapters are commonly used to display data in a list or grid format and support efficient recycling of views to optimize memory usage and scrolling performance.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Basic",
    "subCategoryId": 11
  },
  {
    "id": 112,
    "question": "What is a Service in Android?",
    "answer": "A Service is a component in Android that runs in the background to perform long-running operations or handle remote API calls independently of the UI. It does not have a user interface and can run even if the app is not in the foreground. Services are commonly used for tasks such as playing music, downloading files, or handling network operations.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Basic",
    "subCategoryId": 11
  },
  {
    "id": 113,
    "question": "What is a Content Provider in Android?",
    "answer": "Content Providers in Android are a fundamental component of the Android platform that enables data sharing and inter-application communication. They act as an interface to securely expose data from one app to another or even to the system. Content Providers allow apps to share structured data with other apps, making it possible to access and modify data across different applications while ensuring data security and privacy.\n\nThe primary purpose of Content Providers is to facilitate the sharing of data between apps in a standardized and controlled manner. They are commonly used to share data such as contacts, media files, calendar events, and other structured information. By using Content Providers, developers can offer their app's data to other apps without exposing the underlying data storage details.\n\nContent Providers are part of the Android content framework and are implemented as subclasses of the ContentProvider class. They expose data through a Content URI (Uniform Resource Identifier) that specifies the data's location and format. To access the data, other apps use the ContentResolver class to query, insert, update, or delete data through the Content Provider.\n\nIn summary, Content Providers play a crucial role in Android's data-sharing ecosystem, enabling apps to securely share data with each other while promoting a structured and uniform approach to accessing and managing shared data across the platform.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Basic",
    "subCategoryId": 11
  },
  {
    "id": 114,
    "question": "What is a BroadcastReceiver in Android?",
    "answer": "A BroadcastReceiver is a component in Android that listens for and responds to system-wide broadcast messages or intents. It allows apps to receive and react to events, such as network connectivity changes, battery low notifications, or incoming SMS messages, even if the app is not currently running or in the foreground. BroadcastReceivers are registered in the AndroidManifest.xml file or dynamically at runtime.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Basic",
    "subCategoryId": 11
  },

  {
    "id": 115,
    "question": "What is a RecyclerView in Android?",
    "answer": "A RecyclerView is a more advanced and flexible version of the ListView in Android. It is used to efficiently display large data sets in a scrollable list or grid format. Unlike the ListView, the RecyclerView separates the concerns of data management, item view creation, and item view recycling. It uses a RecyclerView.Adapter to bind data to individual items and a RecyclerView.LayoutManager to handle the arrangement of items on the screen.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Basic",
    "subCategoryId": 11
  },
  {
    "id": 116,
    "question": "What is an AsyncTask in Android?",
    "answer": "An AsyncTask is a helper class in Android that simplifies the execution of background tasks on a separate worker thread while keeping the UI thread responsive. It provides convenient methods for performing tasks asynchronously, such as downloading files, performing network operations, or processing data. AsyncTask consists of three main methods: onPreExecute, doInBackground, and onPostExecute, which are executed on the UI thread and worker thread respectively.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Basic",
    "subCategoryId": 11
  },
  {
    "id": 117,
    "question": "What is a Toast in Android?",
    "answer": "A Toast is a small message that appears as a temporary popup on the screen to display brief information or notifications. It is typically used to show simple feedback or alert messages to the user. Toasts are non-intrusive and automatically disappear after a short duration. They can be created and displayed using the Toast.makeText() method and customized with duration, position, and layout parameters.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Basic",
    "subCategoryId": 11
  },
  {
    "id": 118,
    "question": "What is the Context in Android?",
    "answer": "The Context in Android refers to the current state or environment in which an app is running. It provides access to various resources, services, and information about the app's application environment. The Context is required for performing many essential tasks in Android, such as accessing system services, loading resources, starting activities, and creating views. It is typically passed as a parameter or obtained from the app's components, such as Activity or Application.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Basic",
    "subCategoryId": 11
  },
  {
    "id": 119,
    "question": "What is an APK in Android?",
    "answer": "An APK (Android Package Kit) is the file format used to distribute and install applications on the Android operating system. It contains all the necessary files and metadata required to run the app on an Android device. The APK file is generated by the Android build process and typically includes the compiled code, resources, manifest file, and other assets. Users can install APK files either from app stores like Google Play or by downloading them from other sources.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Basic",
    "subCategoryId": 11
  },
  {
    "id": 120,
    "question": "What is an XML layout file in Android?",
    "answer": "An XML layout file in Android defines the structure and appearance of the user interface for an Activity or Fragment. It is used to describe the placement and properties of UI elements, such as TextViews, Buttons, ImageViews, and more. XML layout files are created in the res/layout directory of an Android project and are inflated at runtime to create the actual views. They allow developers to separate the UI design from the code logic and support multiple device configurations and languages through resource qualifiers.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Basic",
    "subCategoryId": 11
  },
  {
    "id": 121,
    "question": "What is a Context Menu in Android?",
    "answer": "A Context Menu in Android is a floating menu that appears when the user performs a long press on a UI element, such as a button or list item. It provides a set of actions or options related to the selected item. Context menus are commonly used to offer additional functionality or operations on specific items, such as deleting, sharing, or editing. They can be defined in XML or created programmatically using the registerForContextMenu() and onCreateContextMenu() methods.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Basic",
    "subCategoryId": 11
  },
  {
    "id": 122,
    "question": "What is a ViewPager in Android?",
    "answer": "A ViewPager is a UI component in Android that allows the user to swipe horizontally to navigate between multiple pages, typically represented as fragments or views. It is commonly used to create screens with tabs or slide-based content. The ViewPager automatically handles the animation and layout of the pages and provides a smooth scrolling experience. It is often combined with TabLayout to create a tabbed interface with swipeable content.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Basic",
    "subCategoryId": 11
  },
  {
    "id": 123,
    "question": "What is an AlertDialog in Android?",
    "answer": "An AlertDialog is a modal dialog box in Android that displays a message, prompt, or set of options to the user. It is typically used to show important information, ask for confirmation, or prompt the user for input. AlertDialogs can have customizable titles, messages, buttons, and a variety of predefined styles. They are created and displayed using the AlertDialog.Builder class and can handle user interactions through listeners or callbacks.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Basic",
    "subCategoryId": 11
  },
  {
    "id": 124,
    "question": "What is ProGuard in Android?",
    "answer": "ProGuard is a tool in Android used for code shrinking, obfuscation, and optimization. It reduces the size of the APK by removing unused code, renaming classes, fields, and methods to make the code harder to understand and reverse engineer. ProGuard can significantly reduce the APK size and improve the app's performance. It is commonly used in release builds to protect sensitive information, prevent unauthorized code analysis, and improve the app's security.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Basic",
    "subCategoryId": 11
  },

  {
    "id": 127,
    "question": "What is a coroutine in Kotlin?",
    "answer": "A coroutine in Kotlin is a concurrency design pattern that allows you to write asynchronous, non-blocking code in a sequential manner. It provides a way to convert complex asynchronous code into simpler, more readable code by avoiding the use of callbacks and managing concurrency using a structured approach.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Coroutines",
    "subCategoryId": 12
  },
  {
    "id": 128,
    "question": "What are the main advantages of using coroutines?",
    "answer": "Some advantages of using coroutines include: simplified asynchronous programming, sequential code execution, structured concurrency, built-in cancellation support, and coroutine scope for managing lifecycles.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Coroutines",
    "subCategoryId": 12
  },
  {
    "id": 129,
    "question": "How do coroutines differ from threads?",
    "answer": "Coroutines are lightweight and designed for managing concurrency within a single thread. They provide a way to suspend and resume execution at specific points, allowing efficient utilization of resources. In contrast, threads are operating system-level constructs that execute code concurrently and require more system resources.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Coroutines",
    "subCategoryId": 12
  },
  {
    "id": 130,
    "question": "What is a suspend function in Kotlin coroutines?",
    "answer": "A suspend function is a function that can be paused and resumed later without blocking the thread. It is marked with the `suspend` modifier and can only be called from within a coroutine or another suspend function. Suspend functions are used to perform non-blocking operations and can be used to replace blocking IO calls.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Coroutines",
    "subCategoryId": 12
  },
  {
    "id": 131,
    "question": "What is the difference between `launch` and `async` in coroutines?",
    "answer": "In coroutines, `launch` is used to start a new coroutine and it returns a `Job` that represents the coroutine. The `launch` coroutine builder is used for fire-and-forget scenarios where you don't need the result of the coroutine.\n\nOn the other hand, `async` is used to start a new coroutine that computes a result asynchronously. It returns an instance of `Deferred` that represents a future result. You can use the `await` function on the `Deferred` to get the result of the coroutine when needed.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Coroutines",
    "subCategoryId": 12
  },
  {
    "id": 132,
    "question": "What is a coroutine context in Kotlin?",
    "answer": "A coroutine context in Kotlin represents the context in which a coroutine is executed. It includes the coroutine dispatcher and other elements such as coroutine name, exception handler, and parent job. The coroutine context is propagated through coroutines and determines the execution context for suspending functions and coroutine builders. The context can be modified using coroutine builders like `withContext` and `coroutineScope` to change the dispatcher or other elements of the context.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Coroutines",
    "subCategoryId": 12
  },
  {
    "id": 133,
    "question": "What is structured concurrency in Kotlin coroutines?",
    "answer": "Structured concurrency is a principle in Kotlin coroutines that promotes the structured and controlled execution of concurrent operations. It ensures that all launched coroutines are properly completed and resources are released. With structured concurrency, coroutines are organized hierarchically, and child coroutines are automatically canceled if their parent coroutine fails or is canceled. This simplifies error handling and resource management in concurrent code.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Coroutines",
    "subCategoryId": 12
  },
  {
    "id": 134,
    "question": "How can you handle exceptions in coroutines?",
    "answer": "Exceptions in coroutines can be handled using the `try-catch` construct within the coroutine or by using the `CoroutineExceptionHandler` to define a global exception handler for all coroutines within a specific context. Additionally, the `SupervisorJob` can be used to create a hierarchy of coroutines where exceptions in child coroutines do not propagate to their parent coroutine.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Coroutines",
    "subCategoryId": 12
  },
  {
    "id": 135,
    "question": "What is the difference between `launch` and `runBlocking` in coroutines?",
    "answer": "In coroutines, `launch` is a non-blocking coroutine builder that starts a new coroutine and returns a `Job` that represents the coroutine. It is typically used at the top-level to launch coroutines that run in the background.\n\nOn the other hand, `runBlocking` is a blocking coroutine builder that starts a new coroutine and blocks the current thread until the coroutine completes. It is mainly used in test code or in situations where you need to bridge between blocking and non-blocking code.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Coroutines",
    "subCategoryId": 12
  },
  {
    "id": 136,
    "question": "What is coroutine scope in Kotlin?",
    "answer": "Coroutine scope in Kotlin represents a structured concurrency scope for managing the lifecycle of coroutines. It provides a structured way to launch coroutines within a specific context and ensures that all launched coroutines are completed before the scope is completed. Coroutine scope is typically used in conjunction with functions like `coroutineScope`, `viewModelScope`, or custom scopes to manage the lifecycle and cancellation of coroutines in a structured manner.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Coroutines",
    "subCategoryId": 12
  },

  {
    "id": 146,
    "question": "What is the purpose of coroutine cancellation in Kotlin?",
    "answer": "Coroutine cancellation in Kotlin allows you to gracefully terminate the execution of a coroutine. It helps in releasing resources, stopping long-running operations, and preventing memory leaks. Cancellation can be done manually using coroutine scope cancellation functions like `cancel`, or it can be handled automatically by structured concurrency using coroutine cancellation hierarchies.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Coroutines",
    "subCategoryId": 12
  },
  {
    "id": 147,
    "question": "How can you handle coroutine cancellation exceptions in Kotlin?",
    "answer": "When a coroutine is canceled, a `CancellationException` is thrown by default. You can handle this exception using a `try-catch` block around the suspended function call or using the `CoroutineExceptionHandler` to define a global exception handler. Additionally, you can use the `withContext` function to wrap the suspended call in a try-catch block and handle the exception appropriately.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Coroutines",
    "subCategoryId": 12
  },
  {
    "id": 148,
    "question": "What is the purpose of `CoroutineScope` in Kotlin coroutines?",
    "answer": "The `CoroutineScope` interface in Kotlin coroutines provides a way to manage the lifecycle of coroutines. It defines coroutine builders like `launch` and `async` and also contains functions for cancellation, exception handling, and coroutine context management. By implementing or using a `CoroutineScope`, you can control the behavior of coroutines within that scope and ensure proper cleanup and cancellation of coroutines when needed.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Coroutines",
    "subCategoryId": 12
  },
  {
    "id": 149,
    "question": "What is the difference between `withContext` and `async` in coroutines?",
    "answer": "The `withContext` function in coroutines is used to switch the coroutine's context to a different dispatcher. It suspends the current coroutine, switches the execution context, and resumes the coroutine in the new context. It is typically used to perform blocking IO or switch to a different dispatcher.\n\nOn the other hand, `async` is a coroutine builder that starts a new coroutine and returns a `Deferred` object representing the result of the coroutine. It allows parallel execution of multiple coroutines and provides a way to retrieve the result using the `await` function. It is often used when you need to perform multiple concurrent operations and combine their results later.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Coroutines",
    "subCategoryId": 12
  },
  {
    "id": 150,
    "question": "What is the purpose of coroutine scopes like `viewModelScope` and `lifecycleScope`?",
    "answer": "Coroutine scopes like `viewModelScope` and `lifecycleScope` are provided by libraries such as `ViewModel` and `Lifecycle`. They allow you to launch coroutines that are automatically canceled when the associated lifecycle is destroyed. This helps in managing coroutine lifecycles in Android components like ViewModel and Activity/Fragment, ensuring that coroutines are canceled and resources are released appropriately, preventing memory leaks and unnecessary work.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Coroutines",
    "subCategoryId": 12
  },
  {
    "id": 151,
    "question": "What is the difference between `GlobalScope` and `CoroutineScope` in Kotlin?",
    "answer": "The `GlobalScope` is a predefined coroutine scope available globally that allows launching top-level coroutines that are not bound to any specific lifecycle. It has a longer lifecycle than most Android components and is not tied to any specific lifecycle. It is generally recommended to avoid using `GlobalScope` in Android apps.\n\nOn the other hand, `CoroutineScope` is an interface that represents a specific scope for coroutines. It provides functions like `launch` and `async` to launch coroutines within that scope. It is usually associated with a specific lifecycle or context, such as the `viewModelScope` or `lifecycleScope` in Android components.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Coroutines",
    "subCategoryId": 12
  },
  {
    "id": 152,
    "question": "How can you handle coroutine exceptions in Kotlin coroutines?",
    "answer": "Coroutine exceptions in Kotlin coroutines can be handled using the `try-catch` construct within the coroutine or by using the `CoroutineExceptionHandler` to define a global exception handler. Additionally, you can use the `supervisorScope` function to create a separate scope where exceptions in child coroutines do not propagate to the parent scope. This allows for isolated error handling within a coroutine hierarchy.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Coroutines",
    "subCategoryId": 12
  },
  {
    "id": 153,
    "question": "What is the purpose of the `await` function in Kotlin coroutines?",
    "answer": "The `await` function is used to retrieve the result of a `Deferred` object in Kotlin coroutines. It suspends the current coroutine until the result is available, and then resumes the coroutine with the retrieved result. It is typically used in combination with the `async` coroutine builder to perform concurrent operations and wait for their results. The `await` function allows for sequential execution and easy composition of asynchronous operations in a non-blocking manner.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Coroutines",
    "subCategoryId": 12
  },
  {
    "id": 154,
    "question": "What is the difference between `runBlocking` and `coroutineScope` in Kotlin?",
    "answer": "In Kotlin coroutines, `runBlocking` is a blocking coroutine builder that blocks the current thread until the enclosed coroutine is completed. It is typically used in test code or in bridging between blocking and non-blocking code.\n\nOn the other hand, `coroutineScope` is a suspending function that creates a new coroutine scope and suspends the current coroutine until all child coroutines are completed. It is often used when you need to perform multiple concurrent operations and wait for their completion before proceeding.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Coroutines",
    "subCategoryId": 12
  },

  {
    "id": 164,
    "question": "What is Jetpack Compose?",
    "answer": "Jetpack Compose is a modern UI toolkit for building native Android apps. It provides a declarative approach to building user interfaces, allowing you to describe your UI using composable functions. Compose simplifies UI development by eliminating the need for XML layouts and manual view updates. It offers a reactive programming model, automatic state handling, and powerful layout capabilities.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Compose",
    "subCategoryId": 10
  },
  {
    "id": 165,
    "question": "What are the main advantages of using Jetpack Compose?",
    "answer": "Some of the main advantages of using Jetpack Compose include:\n\n1. Declarative UI: Compose allows you to define your UI using composable functions, making it easier to understand and maintain.\n2. Reactive updates: Compose automatically updates the UI when the underlying data changes, reducing boilerplate code.\n3. State management: Compose provides built-in state management capabilities, simplifying the handling of UI state.\n4. Powerful layout system: Compose offers a flexible and powerful layout system that adapts to different screen sizes and orientations.\n5. Interactive and dynamic UI: Compose enables the creation of interactive and dynamic UIs with less code.\n6. Integration with existing code: Compose can be integrated with existing Android code, allowing gradual adoption in existing projects.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Compose",
    "subCategoryId": 10
  },
  {
    "id": 166,
    "question": "What is a composable function in Jetpack Compose?",
    "answer": "A composable function in Jetpack Compose is a function that is annotated with the `@Composable` annotation. These functions are used to define UI components and UI layouts. Composable functions describe the structure and appearance of the UI based on the provided input and state. They can be combined and reused to create complex UI hierarchies.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Compose",
    "subCategoryId": 10
  },
  {
    "id": 167,
    "question": "What is the role of the `setContent` function in Jetpack Compose?",
    "answer": "The `setContent` function is a key function in Jetpack Compose that sets the top-level content of an application or a UI component. It takes a composable function as a parameter, which defines the structure and appearance of the UI. The `setContent` function is typically called in the `onCreate` method of an `Activity` or in the `setContent` method of a Compose `View`.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Compose",
    "subCategoryId": 10
  },
  {
    "id": 168,
    "question": "What is the difference between Compose and traditional Android View-based UI development?",
    "answer": "The main difference between Compose and traditional Android View-based UI development is the approach used to define and update the UI.\n\nIn traditional Android development, UI layouts are defined using XML files (e.g., LinearLayout, RelativeLayout) and are inflated at runtime. View-based UIs require manual view updates to reflect changes in the underlying data.\n\nIn contrast, Compose uses a declarative approach where UI components are defined using composable functions. The UI is automatically updated when the underlying data changes, eliminating the need for manual view updates. Compose provides a reactive programming model that simplifies UI development and reduces boilerplate code.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Compose",
    "subCategoryId": 10
  },
  {
    "id": 169,
    "question": "What is state in Jetpack Compose?",
    "answer": "In Jetpack Compose, state represents the mutable data that can trigger UI updates. State is typically used to hold information that can change over time, such as user input or application state. Compose provides built-in state management functions and data structures, like `mutableStateOf`, to handle state and automatically update the UI when the state changes.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Compose",
    "subCategoryId": 10
  },
  {
    "id": 170,
    "question": "What is the purpose of the `remember` function in Jetpack Compose?",
    "answer": "The `remember` function in Jetpack Compose is used to retain a value across recompositions. It is similar to the concept of state but is optimized for performance. The `remember` function ensures that the value is only recomputed when its inputs change. It is often used to cache expensive computations or to preserve the state of a composable function across recompositions.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Compose",
    "subCategoryId": 10
  },
  {
    "id": 171,
    "question": "What is the purpose of the `Modifier` class in Jetpack Compose?",
    "answer": "The `Modifier` class in Jetpack Compose is used to modify the behavior and appearance of composable functions. It provides a way to apply various transformations, such as size, padding, alignment, and interaction modifiers, to the UI components. The `Modifier` class enables flexible and powerful layout capabilities in Compose.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Compose",
    "subCategoryId": 10
  },
  {
    "id": 172,
    "question": "What is recomposition in Jetpack Compose?",
    "answer": "Recomposition in Jetpack Compose refers to the process of updating the UI based on changes in the underlying data or state. When the data or state used by a composable function changes, Compose automatically triggers a recomposition of that function and its dependent functions. Recomposition ensures that the UI stays up to date with the latest data and reflects the changes in a reactive manner.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Compose",
    "subCategoryId": 10
  },
  {
    "id": 173,
    "question": "What is the purpose of the `rememberCoroutineScope` function in Jetpack Compose?",
    "answer": "The `rememberCoroutineScope` function in Jetpack Compose is used to create and retain a coroutine scope across recompositions. It ensures that coroutines launched within the scope are canceled when the composable function is removed from the composition. This function is useful when working with coroutines in Compose and helps manage the lifecycle of coroutines within the UI.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Compose",
    "subCategoryId": 10
  },

  {
    "id": 183,
    "question": "What are the key principles of Jetpack Compose?",
    "answer": "The key principles of Jetpack Compose include:\n\n1. Declarative UI: Compose provides a declarative approach to UI development, where you describe what the UI should look like based on the current state.\n2. Composable functions: UI components in Compose are built using composable functions, allowing for easy composition and reuse.\n3. Reactive updates: Compose automatically updates the UI when the underlying data changes, ensuring consistency between the UI and the data.\n4. State management: Compose provides built-in tools for managing and observing state, making it easier to handle dynamic UI behavior.\n5. Simplified layouts: Compose offers a flexible and powerful layout system that simplifies the creation of responsive UIs.\n6. Material Design integration: Compose seamlessly integrates with Material Design guidelines and components, providing a modern and consistent UI experience.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Compose",
    "subCategoryId": 10
  },
  {
    "id": 184,
    "question": "What is the purpose of the `rememberSaveable` function in Jetpack Compose?",
    "answer": "The `rememberSaveable` function in Jetpack Compose is used to remember and save the state of a composable function across configuration changes, such as screen rotations. It allows the UI to preserve its state and data when the configuration changes, ensuring a smooth user experience. `rememberSaveable` is often used for preserving form data, scroll positions, or other user interactions that should persist across configuration changes.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Compose",
    "subCategoryId": 10
  },
  {
    "id": 185,
    "question": "What is the purpose of the `rememberCoroutineScope` function in Jetpack Compose?",
    "answer": "The `rememberCoroutineScope` function in Jetpack Compose is used to create and retain a coroutine scope across recompositions. It ensures that coroutines launched within the scope are canceled when the composable function is removed from the composition. This function is useful when working with coroutines in Compose and helps manage the lifecycle of coroutines within the UI.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Compose",
    "subCategoryId": 10
  },
  {
    "id": 186,
    "question": "What is the purpose of the `rememberScrollState` function in Jetpack Compose?",
    "answer": "The `rememberScrollState` function in Jetpack Compose is used to create and retain the state of a scrollable component, such as a `LazyColumn` or `ScrollView`. It tracks the scroll position and provides methods to programmatically scroll the content. `rememberScrollState` is often used in combination with scrollable UI components to create smooth scrolling behavior in Compose applications.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Compose",
    "subCategoryId": 10
  },
  {
    "id": 187,
    "question": "What is the purpose of the `rememberUpdatedState` function in Jetpack Compose?",
    "answer": "The `rememberUpdatedState` function in Jetpack Compose is used to wrap a state value to ensure that it only triggers recomposition if the value has actually changed. This function is useful when working with mutable state that doesn't properly trigger recompositions on its own. By wrapping the state value with `rememberUpdatedState`, you can ensure that only relevant changes trigger recompositions, optimizing performance in Compose applications.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Compose",
    "subCategoryId": 10
  },
  {
    "id": 188,
    "question": "What is the purpose of the `rememberCoroutineScope` function in Jetpack Compose?",
    "answer": "The `rememberCoroutineScope` function in Jetpack Compose is used to create and retain a coroutine scope across recompositions. It ensures that coroutines launched within the scope are canceled when the composable function is removed from the composition. This function is useful when working with coroutines in Compose and helps manage the lifecycle of coroutines within the UI.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Compose",
    "subCategoryId": 10
  },
  {
    "id": 189,
    "question": "What is the purpose of the `rememberUpdatedState` function in Jetpack Compose?",
    "answer": "The `rememberUpdatedState` function in Jetpack Compose is used to wrap a state value to ensure that it only triggers recomposition if the value has actually changed. This function is useful when working with mutable state that doesn't properly trigger recompositions on its own. By wrapping the state value with `rememberUpdatedState`, you can ensure that only relevant changes trigger recompositions, optimizing performance in Compose applications.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Compose",
    "subCategoryId": 10
  },
  {
    "id": 190,
    "question": "What is the purpose of the `LaunchedEffect` composable in Jetpack Compose?",
    "answer": "The `LaunchedEffect` composable in Jetpack Compose is used to launch a coroutine when the composable is initially displayed or recomposed. It is similar to the `Effect` composable but automatically cancels the coroutine when the composable is removed from the composition. `LaunchedEffect` is often used for performing side-effects, such as fetching data from a network or updating a database, in response to changes in the composition or user interactions.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Compose",
    "subCategoryId": 10
  },
  {
    "id": 191,
    "question": "What is the purpose of the `rememberCoroutineScope` function in Jetpack Compose?",
    "answer": "The `rememberCoroutineScope` function in Jetpack Compose is used to create and retain a coroutine scope across recompositions. It ensures that coroutines launched within the scope are canceled when the composable function is removed from the composition. This function is useful when working with coroutines in Compose and helps manage the lifecycle of coroutines within the UI.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Compose",
    "subCategoryId": 10
  },
  {
    "id": 192,
    "question": "Describe dispatchers in Coroutines",
    "answer": "Dispatchers in Coroutines are used to specify the thread or thread pool on which a coroutine should run. Coroutines can be launched on various dispatchers to control their execution context. Some commonly used dispatchers are:\n\n- `Dispatchers.Default`: This uses a shared background pool of threads and is suitable for CPU-intensive operations.\n- `Dispatchers.IO`: This is optimized for I/O tasks such as reading from or writing to files or making network requests.\n- `Dispatchers.Main`: This is the main thread dispatcher and is used for updating the UI.\n\nYou can also create your own custom dispatchers if needed. It's important to choose the appropriate dispatcher for each coroutine to ensure efficient and non-blocking execution.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Coroutines",
    "subCategoryId": 4
  },
  {
    "id": 193,
    "question": "What is the difference between lifecycleScope and viewModelScope?",
    "answer": "Both `lifecycleScope` and `viewModelScope` are Kotlin Coroutine Scopes available in Android.\n\n`lifecycleScope`: It is a CoroutineScope tied to the lifecycle of an Android component, typically an Activity or Fragment. When the associated component is destroyed, all coroutines launched in `lifecycleScope` will be automatically canceled, helping to avoid memory leaks and unnecessary work.\n\n`viewModelScope`: It is a CoroutineScope tied to the lifecycle of a ViewModel. It allows launching coroutines that are tied to the ViewModel's lifecycle. When the ViewModel is cleared or destroyed (e.g., during configuration changes or when the activity is finished), all coroutines in `viewModelScope` will be automatically canceled.\n\nIn summary, `lifecycleScope` is typically used for coroutines that should be tied to the lifecycle of an Activity or Fragment, while `viewModelScope` is used for coroutines that should be tied to the lifecycle of a ViewModel.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Coroutines",
    "subCategoryId": 4
  },
  {
    "id": 194,
    "question": "What is the difference between suspending and blocking in Kotlin coroutines?",
    "answer": "In Kotlin coroutines, suspending and blocking are two different concepts related to handling concurrency.\n\nSuspending: A suspending function is a function that can be paused and resumed later without blocking the thread. It is marked with the `suspend` keyword in its signature. Suspending functions are designed to perform asynchronous operations without blocking the main thread. When a suspending function is called, it may suspend its execution until the result is available, but it does not block the thread. Instead, it allows other tasks to be executed on the same thread.\n\nBlocking: A blocking function, on the other hand, is a function that blocks the thread until the operation is completed. When a blocking function is called, it prevents the thread from executing any other tasks until the operation is finished. This can lead to performance issues, especially in Android applications, where blocking the main thread can cause the app to become unresponsive.\n\nIn summary, suspending functions allow asynchronous operations without blocking the thread, while blocking functions halt the execution of the thread until the operation is complete.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Coroutines",
    "subCategoryId": 4
  },
  {
    "id": 195,
    "question": "What is SupervisorScope, and how is it used with SupervisorJob in Kotlin coroutines?",
    "answer": "In Kotlin coroutines, `SupervisorScope` and `SupervisorJob` are used to create a scope that handles the failure of child coroutines independently. When a coroutine fails due to an exception in a `SupervisorScope`, the failure is contained to that specific coroutine, and the exception does not propagate to the parent or other sibling coroutines within the same scope.\n\nHere's how you can use `SupervisorScope` with `SupervisorJob`:\n\n```\nimport kotlinx.coroutines.*\n\nclass MyViewModel : ViewModel() {\n\n    // Create a SupervisorJob\n    private val supervisorJob = SupervisorJob()\n\n    // Create a CoroutineScope using the SupervisorJob\n    private val viewModelScope = CoroutineScope(Dispatchers.Main + supervisorJob)\n\n    fun doSomething() {\n        // Start a coroutine within the SupervisorScope\n        viewModelScope.launch {\n            try {\n                // Do some work that might throw an exception\n                // ...\n            } catch (e: Exception) {\n                // Exception handling specific to this coroutine\n                // It won't affect other coroutines within the same scope\n            }\n        }\n    }\n\n    // Function to cancel all child coroutines when needed\n    fun cancelAllCoroutines() {\n        supervisorJob.cancelChildren()\n    }\n}\n```\n\nBy using `SupervisorScope` with `SupervisorJob`, you can create fault-tolerant coroutines that handle exceptions in a way that isolates them from other coroutines within the same scope.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Coroutines",
    "subCategoryId": 4
  },
  {
    "id": 196,
    "question": "What is the difference between Scope cancellation and cancellation of its children in Kotlin coroutines?",
    "answer": "In Kotlin coroutines, scope cancellation and cancellation of its children refer to different ways of handling coroutines within a coroutine scope when the scope itself is canceled.\n\n1. Scope Cancellation:\nWhen a coroutine scope is canceled using its `cancel` function or if the scope's job is completed or canceled, all coroutines launched within that scope are canceled. This includes both the coroutine that launched the children coroutines and the children coroutines themselves. The cancellation is propagated down the coroutine hierarchy.\n\n2. Cancellation of Children:\nOn the other hand, if a specific coroutine is canceled using its `cancel` function, only that particular coroutine is canceled. The cancellation does not affect other coroutines launched within the same scope. It's a localized cancellation that doesn't propagate up or down the hierarchy.\n\nIn summary, scope cancellation affects all coroutines within that scope, whereas cancellation of children affects only the targeted coroutine, leaving other coroutines in the scope unaffected.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Coroutines",
    "subCategoryId": 4
  },
  {
    "id": 245,
    "question": "Data and file storage overview",
    "answer": "In Android, data and file storage are essential for storing various types of information used by apps. Data storage options include Shared Preferences, which are used to store key-value pairs, and SQLite databases, which provide a structured way to store relational data. File storage can be achieved using internal storage, external storage (SD card), or cache directories. Each storage option has its advantages and use cases, depending on the type of data to be stored and the level of security required.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Android Platform",
    "subCategoryId": 11
  },
  {
    "id": 246,
    "question": "targetSdkVersion behavior",
    "answer": "The targetSdkVersion is an attribute in the AndroidManifest.xml file that specifies the highest API level that the app is designed to run on. It affects the app's behavior when running on devices with newer versions of Android. If the targetSdkVersion is set to a lower API level, the app runs in compatibility mode, and some newer features and behaviors are disabled to maintain compatibility with the specified version. On the other hand, setting targetSdkVersion to the latest API level allows the app to use the latest features and optimizations available in the newer Android versions.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Android Platform",
    "subCategoryId": 11
  },
  {
    "id": 247,
    "question": "Obfuscation in Android",
    "answer": "Obfuscation is the process of transforming the app's code to make it more challenging to understand or reverse-engineer. In Android, ProGuard is a widely used tool for code obfuscation. ProGuard renames classes, fields, and methods to short, meaningless names, making the code harder to decipher. Additionally, it removes unused code and resources, resulting in a smaller APK size. Obfuscation helps to protect intellectual property and sensitive information, such as API keys, from being easily extracted by malicious users.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Android Platform",
    "subCategoryId": 11
  },
  {
    "id": 248,
    "question": "Serializable vs Parcelable",
    "answer": "Serializable and Parcelable are two mechanisms in Android used to transfer objects between components, such as activities and fragments. Serializable is a standard Java interface that serializes an object into a byte stream, allowing it to be easily saved to storage or transmitted over the network. However, it can be slow and inefficient. Parcelable is an Android-specific interface that serializes an object into a Parcel, which is optimized for Android's IPC (Inter-Process Communication). Parcelable is faster and more efficient than Serializable, making it the preferred choice for passing data between components within an Android app.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Android Platform",
    "subCategoryId": 11
  },
  {
    "id": 249,
    "question": "Permissions on Android",
    "answer": "Permissions in Android are security measures that control an app's access to device resources and user data. Android uses a permission system to ensure that apps request access to sensitive information or features only when necessary and that users are aware of the requested access. Common Android permissions include access to the camera, microphone, contacts, location, and storage. Users must grant permissions before an app can access the corresponding resources or data.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Android Platform",
    "subCategoryId": 11
  },
  {
    "id": 250,
    "question": "Requesting permissions in Android",
    "answer": "To request permissions in Android, developers need to declare the required permissions in the AndroidManifest.xml file. At runtime, the app must explicitly request dangerous permissions from the user using the runtime permission model introduced in Android 6.0 (API level 23) and higher. When a permission is requested, the user is presented with a dialog explaining why the app needs the permission. The user can choose to grant or deny the permission. If the permission is denied, the app should handle the situation gracefully and provide alternative functionality.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Android Platform",
    "subCategoryId": 11
  },
  {
    "id": 251,
    "question": "compileSdk vs targetSdk",
    "answer": "In Android, 'compileSdkVersion' and 'targetSdkVersion' are two important attributes in the build.gradle file. 'compileSdkVersion' specifies the Android API level that the app is compiled against, providing access to the corresponding APIs and features during development. 'targetSdkVersion', on the other hand, is the highest API level that the app is designed to run on. It affects the app's behavior on devices with newer versions of Android. The app runs in compatibility mode if 'targetSdkVersion' is set to a lower API level, while setting it to the latest API level allows the app to use the latest features and optimizations available in the newer Android versions.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Android Platform",
    "subCategoryId": 11
  },
  {
    "id": 252,
    "question": "Describe Android operating system",
    "answer": "Android is a mobile operating system developed by Google based on the Linux kernel and designed primarily for touchscreen devices such as smartphones and tablets. It is open-source and allows developers to create and customize apps using Java or Kotlin programming languages. Android offers a rich set of APIs and frameworks for building a wide range of applications, including games, social media apps, productivity tools, and more. It provides features like multi-tasking, notifications, widgets, and support for various hardware components, making it a versatile and popular platform for mobile development.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Android Platform",
    "subCategoryId": 11
  },
  {
    "id": 253,
    "question": "What are intents in Android?",
    "answer": "Intents are a fundamental component of Android's inter-application communication system. They are messages that allow components, such as activities, services, and broadcast receivers, to request actions from other components or to respond to actions from other components. Intents can be explicit, specifying the target component, or implicit, defining the action and data and letting the system determine the suitable components to handle the request. Intents play a vital role in launching activities, starting services, and broadcasting events in Android applications.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Android Platform",
    "subCategoryId": 11
  },
  {
    "id": 254,
    "question": "What are memory leaks in Android?",
    "answer": "Memory leaks in Android occur when an app unintentionally retains references to objects that are no longer needed, preventing the system from reclaiming memory occupied by those objects. If memory leaks are not addressed, they can lead to increased memory usage, degraded app performance, and even app crashes due to OutOfMemoryErrors. Common causes of memory leaks in Android include holding references to objects across configuration changes, failing to unregister listeners or callbacks, and improper usage of static variables or singleton patterns. Proper memory management and understanding the Android activity lifecycle are essential to avoid memory leaks in Android apps.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Android Platform",
    "subCategoryId": 11
  },
  {
    "id": 255,
    "question": "Activity lifecycle in Android",
    "answer": "The Activity lifecycle in Android defines the different states an activity goes through during its lifetime. It consists of several callback methods that allow developers to manage the state and behavior of an activity. The basic lifecycle states are 'onCreate', 'onStart', 'onResume', 'onPause', 'onStop', 'onDestroy', and 'onRestart'. Activities transition between these states as they are created, started, resumed, paused, stopped, and destroyed by the system or user interactions. Understanding the activity lifecycle is crucial for managing resources, saving and restoring state, and providing a smooth user experience in Android applications.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Android Platform",
    "subCategoryId": 11
  },
  {
    "id": 256,
    "question": "Fragment lifecycle in Android",
    "answer": "Fragments in Android also have a lifecycle similar to activities, with lifecycle methods such as 'onAttach', 'onCreate', 'onViewCreated', 'onStart', 'onResume', 'onPause', 'onStop', 'onDestroyView', 'onDestroy', and 'onDetach'. Fragments can be attached to activities and can be dynamically added, removed, and replaced within an activity. Properly managing the fragment lifecycle is crucial for creating responsive and flexible UIs, handling configuration changes, and maintaining a good user experience in Android apps that use fragments.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Android Platform",
    "subCategoryId": 11
  }

]
