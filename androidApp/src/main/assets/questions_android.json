[
  {
    "id": 1,
    "question": "What are Coroutines in Android?",
    "answer": "Coroutines are a concurrency design pattern introduced in Kotlin. They provide a way to write asynchronous and non-blocking code in a sequential and more readable manner.",
    "difficulty": "Easy",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Coroutines",
    "subCategoryId": 1
  },
  {
    "id": 2,
    "question": "What are the main advantages of using Coroutines in Android development?",
    "answer": "Coroutines offer several benefits, such as simplified concurrency, structured concurrency, easy cancellation, built-in support for asynchronous operations, and seamless integration with Kotlin.",
    "difficulty": "Medium",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Coroutines",
    "subCategoryId": 1
  },
  {
    "id": 3,
    "question": "What is the difference between launch() and async() functions in Coroutines?",
    "answer": "The launch() function is used for fire-and-forget style operations, while the async() function is used when you need to obtain a result from the coroutine. The async() function returns a deferred value that can be used to retrieve the result later.",
    "difficulty": "Medium",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Coroutines",
    "subCategoryId": 1
  },
  {
    "id": 4,
    "question": "How can you handle exceptions in Coroutines?",
    "answer": "In Coroutines, you can handle exceptions using try-catch blocks within the coroutine or by using the CoroutineExceptionHandler to handle uncaught exceptions in a centralized manner.",
    "difficulty": "Easy",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Coroutines",
    "subCategoryId": 1
  },
  {
    "id": 5,
    "question": "What is a CoroutineScope in Android?",
    "answer": "A CoroutineScope is an interface provided by the Coroutine library that defines a context for coroutines. It manages the lifecycle of coroutines and provides the necessary functions to launch and manage coroutines within its scope.",
    "difficulty": "Easy",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Coroutines",
    "subCategoryId": 1
  },
  {
    "id": 8,
    "question": "What is Jetpack Compose?",
    "answer": "Jetpack Compose is a modern toolkit for building native Android UI using a declarative approach. It simplifies the UI development process and offers a more efficient way to create dynamic and interactive user interfaces.",
    "difficulty": "Medium",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Compose",
    "subCategoryId": 3
  },
  {
    "id": 9,
    "question": "What are the key benefits of using Jetpack Compose?",
    "answer": "Jetpack Compose provides benefits such as simplified UI development, declarative UI programming model, efficient UI updates with state management, built-in support for theming and animations, and improved testing and debugging capabilities.",
    "difficulty": "Medium",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Compose",
    "subCategoryId": 3
  },
  {
    "id": 15,
    "question": "What does subscribeOn(scheduler) do?",
    "answer": "The `subscribeOn` operator is used on Observables to specify the thread on which Observers should receive the emitted items. It asynchronously subscribes Observers to the ObservableSource on the specified Scheduler.",
    "difficulty": "Medium",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Rx",
    "subCategoryId": 7
  },
  {
    "id": 16,
    "question": "RxJava Operators - Defer",
    "answer": "The `defer` operator delays the creation of an Observable until an Observer subscribes. It ensures that each Observer receives a fresh instance of the Observable.",
    "difficulty": "Easy",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Rx",
    "subCategoryId": 7
  },
  {
    "id": 17,
    "question": "RxJava Operators - Interval",
    "answer": "The `interval` operator creates an Observable that emits a sequence of integers spaced by a specified time interval. It is useful for creating timers, periodic tasks, or scheduling actions.",
    "difficulty": "Medium",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Rx",
    "subCategoryId": 7
  },
  {
    "id": 18,
    "question": "RxJava Operators - Timer",
    "answer": "The `timer` operator creates an Observable that emits a single item after a specified delay. It is useful for triggering actions after a certain period of time.",
    "difficulty": "Easy",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Rx",
    "subCategoryId": 7
  },
  {
    "id": 19,
    "question": "RxJava Operators - Buffer",
    "answer": "The `buffer` operator periodically gathers items emitted by an Observable into bundles and emits these bundles instead of emitting the items one at a time. It is useful for grouping or batching emitted items.",
    "difficulty": "Medium",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Rx",
    "subCategoryId": 7
  },
  {
    "id": 20,
    "question": "RxJava Operators - FlatMap",
    "answer": "The `flatMap` operator transforms the items emitted by an Observable into Observables, then flattens the emissions from those Observables into a single Observable. Note that the order of emissions may not be preserved.",
    "difficulty": "Medium",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Rx",
    "subCategoryId": 7
  },
  {
    "id": 21,
    "question": "RxJava Operators - Scan",
    "answer": "The `scan` operator applies a function to each item emitted by an Observable, sequentially, and emits each intermediate result. It is useful for performing calculations or accumulating values over time.",
    "difficulty": "Medium",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Rx",
    "subCategoryId": 7
  },
  {
    "id": 22,
    "question": "RxJava Operators - Debounce",
    "answer": "The `debounce` operator only emits an item from an Observable if a specified timespan has passed without any subsequent emissions. It is useful for handling events that occur too frequently.",
    "difficulty": "Medium",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Rx",
    "subCategoryId": 7
  },
  {
    "id": 23,
    "question": "RxJava Operators - Distinct",
    "answer": "The `distinct` operator suppresses duplicate items emitted by an Observable, ensuring that only unique items are passed along. It is useful for filtering out repeated values.",
    "difficulty": "Medium",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Rx",
    "subCategoryId": 7
  },
  {
    "id": 24,
    "question": "RxJava Operators - IgnoreElements",
    "answer": "The `ignoreElements` operator does not emit any items from an Observable but mirrors its termination notification. It is useful when you are only interested in the completion or error signal of an Observable.",
    "difficulty": "Easy",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Rx",
    "subCategoryId": 7
  },
  {
    "id": 25,
    "question": "RxJava Operators - Last",
    "answer": "The `last` operator emits only the last item emitted by an Observable, or a default item if the Observable completes without emitting any items. It is useful for retrieving the last value of a sequence.",
    "difficulty": "Easy",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Rx",
    "subCategoryId": 7
  },
  {
    "id": 26,
    "question": "RxJava Operators - Sample",
    "answer": "The `sample` operator emits the most recent item emitted by an Observable within periodic time intervals. It is useful for sampling values at regular intervals or based on external events.",
    "difficulty": "Medium",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Rx",
    "subCategoryId": 7
  },
  {
    "id": 27,
    "question": "RxJava Operators - Take, TakeLast",
    "answer": "The `take` operator emits only the first n items emitted by an Observable, while the `takeLast` operator emits only the last n items emitted by an Observable. They are useful for limiting the number of emitted items.",
    "difficulty": "Easy",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Rx",
    "subCategoryId": 7
  },
  {
    "id": 28,
    "question": "RxJava Operators - CombineLatest",
    "answer": "The `combineLatest` operator combines the emissions of multiple Observables together via a specified function and emits items based on the results of this function. It triggers emissions whenever any of the combined Observables emit an item.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Rx",
    "subCategoryId": 7
  },
  {
    "id": 29,
    "question": "RxJava Operators - Join",
    "answer": "The `join` operator combines items emitted by two Observables whenever an item from one Observable is emitted during a time window defined according to an item emitted by the other Observable. It is useful for handling temporal relationships between items.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Rx",
    "subCategoryId": 7
  },
  {
    "id": 30,
    "question": "RxJava Operators - Merge",
    "answer": "The `merge` operator combines multiple Observables into one by merging their emissions. It interleaves the items emitted by the source Observables, emitting them as they arrive. It is useful for combining concurrent streams of data.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Rx",
    "subCategoryId": 7
  },
  {
    "id": 31,
    "question": "RxJava Operators - StartWith",
    "answer": "The `startWith` operator emits a specified sequence of items before beginning to emit the items from the source Observable. It is useful for prepending initial or default values to an Observable sequence.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Rx",
    "subCategoryId": 7
  },
  {
    "id": 32,
    "question": "RxJava Operators - Switch",
    "answer": "The `switch` operator converts an Observable that emits Observables into a single Observable that emits the items emitted by the most-recently-emitted Observable. It switches to a new Observable whenever a new one is emitted.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Rx",
    "subCategoryId": 7
  },
  {
    "id": 33,
    "question": "RxJava Operators - Zip",
    "answer": "The `zip` operator combines the emissions of multiple Observables together via a specified function and emits single items for each combination based on the results of this function. It emits items only when all combined Observables have emitted an item.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Rx",
    "subCategoryId": 7
  },
  {
    "id": 34,
    "question": "RxJava Operators - ObserveOn",
    "answer": "The `observeOn` operator specifies the scheduler on which an observer will observe the emissions of an Observable. It is useful for specifying the thread or scheduler for consuming or processing emitted items.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Rx",
    "subCategoryId": 7
  },
  {
    "id": 35,
    "question": "RxJava Operators - Subscribe",
    "answer": "The `subscribe` operator allows you to operate upon the emissions and notifications from an Observable. It provides various overloads to specify the actions to be taken on each emitted item, error, or completion signal.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Rx",
    "subCategoryId": 7
  },
  {
    "id": 36,
    "question": "RxJava Operators - Map",
    "answer": "The `map` operator transforms the items emitted by an Observable by applying a function to each item. It allows you to perform a one-to-one transformation of the emitted values.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Rx",
    "subCategoryId": 7
  },
  {
    "id": 37,
    "question": "RxJava Operators - Window",
    "answer": "The `window` operator periodically subdivides items from an Observable into Observable windows and emits these windows instead of emitting the items one at a time. It is useful for grouping or batching emitted items into separate Observables.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Rx",
    "subCategoryId": 7
  },
  {
    "id": 38,
    "question": "Describe StateFlow.",
    "answer": "State flow is a special-purpose, high-performance, and efficient implementation of SharedFlow for the narrow, but widely used case of sharing a state. State flow always has an initial value, replays one most recent value to new subscribers, does not buffer any more values, but keeps the last emitted one, and does not support resetReplayCache. MutableStateFlow(initialValue) is a shared flow with the following parameters: val shared = MutableSharedFlow(replay = 1, onBufferOverflow = BufferOverflow.DROP_OLDEST) shared.tryEmit(initialValue) emit the initial value val state = shared.distinctUntilChanged() get StateFlow-like behavior. A SharedFlow that represents a read-only state with a single updatable data value that emits updates to the value to its collectors. A state flow is a hot flow because its active instance exists independently of the presence of collectors. Its current value can be retrieved via the value property. When a new consumer starts collecting from the flow, it receives the last state in the stream and any subsequent states.",
    "difficulty": "Medium",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "StateAndSharedFlow",
    "subCategoryId": 8
  },
  {
    "id": 39,
    "question": "Describe the differences and similarities between State Flow & Shared Flow.",
    "answer": "StateFlow is a specialized configuration of SharedFlow optimized for sharing state: the last emitted item is replayed to new collectors, and items are conflated using Any.equals. Similarities: - StateFlow & SharedFlow are both hot flows - They are both Flows. Differences: - SharedFlows are used for one-time-events, such as displaying Snackbar or Toasts - StateFlow will automatically emit the value after, for example, device rotates - StateFlow would not re-emit the same value, so i.e., displaying the same Snackbar multiple times would be impossible.",
    "difficulty": "Medium",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "StateAndSharedFlow",
    "subCategoryId": 8
  },
  {
    "id": 40,
    "question": "Describe SharedFlow.",
    "answer": "A hot Flow that shares emitted values among all its collectors in a broadcast fashion so that all collectors get all emitted values. A shared flow is called hot because its active instance exists independently of the presence of collectors. This is opposed to a regular Flow, such as defined by the flow { ... } function, which is cold and is started separately for each collector. SharedFlow is useful for broadcasting events that happen inside an application to subscribers that can come and go. A shared flow keeps a specific number of the most recent values in its replay cache. Every new subscriber first gets the values from the replay cache and then gets new emitted values. The maximum size of the replay cache is specified when the shared flow is created by the replay parameter. A snapshot of the current replay cache is available via the replayCache property, and it can be reset with the MutableSharedFlow.resetReplayCache function. Use SharedFlow when you need a StateFlow with tweaks in its behavior such as extra buffering, replaying more values, or omitting the initial value.",
    "difficulty": "Medium",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "StateAndSharedFlow",
    "subCategoryId": 8
  },
  {
    "id": 41,
    "question": "What is a hot flow? What is a cold flow?",
    "answer": "A cold flow does not start producing values until one starts to collect them. Cold flows are created on-demand and emit data when they’re being observed. On the other hand, a hot flow starts producing values immediately and is always active, even if there are no subscribers/collectors. Hot flows are better for sharing state across multiple observers.",
    "difficulty": "Easy",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "StateAndSharedFlow",
    "subCategoryId": 9
  },
  {
    "id": 42,
    "question": "LiveData vs StateFlow",
    "answer": "LiveData is an Android-only class and is therefore unfit for the domain and data layer. StateFlow, on the other hand, is a Flow, which enables the use of powerful Flow operators and is not limited to the Android platform.",
    "difficulty": "Easy",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "StateAndSharedFlow",
    "subCategoryId": 9
  },
  {
    "id": 43,
    "question": "launchWhenStarted{ }, repeatOnLifecycle {}",
    "answer": "The `launchWhenStarted` function launches and runs the given block when the Lifecycle controlling the LifecycleCoroutineScope is at least in the STARTED state. The returned Job will be cancelled when the Lifecycle is destroyed. However, this API is not recommended to use as it can lead to wasted resources in some cases. It is recommended to use the `Lifecycle.repeatOnLifecycle` API instead, which will be removed in a future release.",
    "difficulty": "Easy",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Coroutines",
    "subCategoryId": 9
  },
  {
    "id": 44,
    "question": "repeatOnLifecycle() {}",
    "answer": "The `repeatOnLifecycle` function launches the block in a new coroutine every time the lifecycle is in the STARTED state or above, and cancels it when it's in the STOPPED state.",
    "difficulty": "Easy",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Coroutines",
    "subCategoryId": 9
  },
  {
    "id": 45,
    "question": "Flow vs StateFlow & LiveData",
    "answer": "Flow does not hold a state. On the other hand, StateFlow and LiveData are both Flow-based implementations that can hold and emit a state. StateFlow is optimized for sharing state with additional features such as replaying the last emitted value, while LiveData is specifically designed for use in Android applications and provides lifecycle-aware behavior.",
    "difficulty": "Easy",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "StateAndSharedFlow",
    "subCategoryId": 8
  },
  {
    "id": 46,
    "question": "shareIn(), stateIn()",
    "answer": "The `shareIn` and `stateIn` operators convert cold flows into hot flows. They multicast the information that comes from a cold upstream flow to multiple collectors. A cold flow is created on-demand and emits data when it's being observed, while a hot flow is always active and can emit data regardless of whether or not it's being observed.",
    "difficulty": "Easy",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "StateAndSharedFlow",
    "subCategoryId": 8
  },
  {
    "id": 48,
    "question": "Compose",
    "answer": "Jetpack Compose is a modern UI toolkit for building native Android UIs. It offers a declarative approach to building user interfaces, where you describe your UI and Compose takes care of the rest. Compose intelligently determines which parts of the UI need to be redrawn at any given time, resulting in efficient UI updates. It simplifies UI development by allowing you to focus on what the UI should look like rather than how to update it in response to state changes. With Compose, you can create dynamic, interactive, and highly customizable UIs with less code compared to traditional Android View-based development.",
    "difficulty": "Easy",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Compose",
    "subCategoryId": 10
  },
  {
    "id": 105,
    "question": "What is an Activity in Android?",
    "answer": "An Activity is a core component in Android that represents a single screen with a user interface. It is a window that contains the UI elements and responds to user interactions. Each Activity is independent and can be launched by an Intent or as part of a task.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Basic",
    "subCategoryId": 11
  },
  {
    "id": 106,
    "question": "What is an Intent in Android?",
    "answer": "An Intent is a messaging object in Android that is used to request an action from another component, such as starting an Activity, broadcasting a message, or invoking a service. It can carry data using extras and can specify the target component explicitly or implicitly based on the action and data.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Basic",
    "subCategoryId": 11
  },
  {
    "id": 107,
    "question": "What is a Fragment in Android?",
    "answer": "A Fragment is a modular section of an Activity that represents a reusable portion of the user interface and behavior. Fragments are used to build flexible and dynamic UI designs that can be combined and reused across multiple Activities. They have their own lifecycle and can be added or replaced within an Activity dynamically.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Basic",
    "subCategoryId": 11
  },
  {
    "id": 108,
    "question": "What is the AndroidManifest.xml file in Android?",
    "answer": "The AndroidManifest.xml file is an essential configuration file in an Android app that provides essential information about the app to the Android system. It contains details such as the app's package name, declared components (Activities, Services, Broadcast Receivers), required permissions, and hardware requirements. It acts as a blueprint for the Android system to understand and interact with the app.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Basic",
    "subCategoryId": 11
  },
  {
    "id": 109,
    "question": "What is Gradle in Android?",
    "answer": "Gradle is a build system in Android used for building and managing the app's dependencies, resources, and configuration. It uses a Groovy or Kotlin-based DSL (Domain-Specific Language) for defining the build scripts. Gradle is highly customizable and allows developers to automate repetitive tasks, handle different build variants, and integrate with external libraries and plugins.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Basic",
    "subCategoryId": 11
  },
  {
    "id": 110,
    "question": "What is a Layout in Android?",
    "answer": "A Layout in Android is a container that holds UI elements and arranges them on the screen. It defines the structure and appearance of the user interface. Android provides various types of layouts, such as LinearLayout, RelativeLayout, ConstraintLayout, and FrameLayout, to organize and position the UI elements in different ways.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Basic",
    "subCategoryId": 11
  },
  {
    "id": 111,
    "question": "What is an Adapter in Android?",
    "answer": "An Adapter is a bridge between the UI components (such as ListView, RecyclerView) and the data source. It provides data to the UI components, creates views for each item, and handles user interactions. Adapters are commonly used to display data in a list or grid format and support efficient recycling of views to optimize memory usage and scrolling performance.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Basic",
    "subCategoryId": 11
  },
  {
    "id": 112,
    "question": "What is a Service in Android?",
    "answer": "A Service is a component in Android that runs in the background to perform long-running operations or handle remote API calls independently of the UI. It does not have a user interface and can run even if the app is not in the foreground. Services are commonly used for tasks such as playing music, downloading files, or handling network operations.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Basic",
    "subCategoryId": 11
  },
  {
    "id": 113,
    "question": "What is a Content Provider in Android?",
    "answer": "A Content Provider is a component in Android that manages access to a structured set of data, typically stored in a SQLite database or accessed through a network API. It allows different apps to securely share data and provides a consistent interface to access and manipulate the data. Content Providers are commonly used in conjunction with ContentResolver to perform CRUD (Create, Read, Update, Delete) operations on the shared data.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Basic",
    "subCategoryId": 11
  },
  {
    "id": 114,
    "question": "What is a BroadcastReceiver in Android?",
    "answer": "A BroadcastReceiver is a component in Android that listens for and responds to system-wide broadcast messages or intents. It allows apps to receive and react to events, such as network connectivity changes, battery low notifications, or incoming SMS messages, even if the app is not currently running or in the foreground. BroadcastReceivers are registered in the AndroidManifest.xml file or dynamically at runtime.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Basic",
    "subCategoryId": 11
  },

  {
    "id": 115,
    "question": "What is a RecyclerView in Android?",
    "answer": "A RecyclerView is a more advanced and flexible version of the ListView in Android. It is used to efficiently display large data sets in a scrollable list or grid format. Unlike the ListView, the RecyclerView separates the concerns of data management, item view creation, and item view recycling. It uses a RecyclerView.Adapter to bind data to individual items and a RecyclerView.LayoutManager to handle the arrangement of items on the screen.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Basic",
    "subCategoryId": 11
  },
  {
    "id": 116,
    "question": "What is an AsyncTask in Android?",
    "answer": "An AsyncTask is a helper class in Android that simplifies the execution of background tasks on a separate worker thread while keeping the UI thread responsive. It provides convenient methods for performing tasks asynchronously, such as downloading files, performing network operations, or processing data. AsyncTask consists of three main methods: onPreExecute, doInBackground, and onPostExecute, which are executed on the UI thread and worker thread respectively.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Basic",
    "subCategoryId": 11
  },
  {
    "id": 117,
    "question": "What is a Toast in Android?",
    "answer": "A Toast is a small message that appears as a temporary popup on the screen to display brief information or notifications. It is typically used to show simple feedback or alert messages to the user. Toasts are non-intrusive and automatically disappear after a short duration. They can be created and displayed using the Toast.makeText() method and customized with duration, position, and layout parameters.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Basic",
    "subCategoryId": 11
  },
  {
    "id": 118,
    "question": "What is the Context in Android?",
    "answer": "The Context in Android refers to the current state or environment in which an app is running. It provides access to various resources, services, and information about the app's application environment. The Context is required for performing many essential tasks in Android, such as accessing system services, loading resources, starting activities, and creating views. It is typically passed as a parameter or obtained from the app's components, such as Activity or Application.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Basic",
    "subCategoryId": 11
  },
  {
    "id": 119,
    "question": "What is an APK in Android?",
    "answer": "An APK (Android Package Kit) is the file format used to distribute and install applications on the Android operating system. It contains all the necessary files and metadata required to run the app on an Android device. The APK file is generated by the Android build process and typically includes the compiled code, resources, manifest file, and other assets. Users can install APK files either from app stores like Google Play or by downloading them from other sources.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Basic",
    "subCategoryId": 11
  },
  {
    "id": 120,
    "question": "What is an XML layout file in Android?",
    "answer": "An XML layout file in Android defines the structure and appearance of the user interface for an Activity or Fragment. It is used to describe the placement and properties of UI elements, such as TextViews, Buttons, ImageViews, and more. XML layout files are created in the res/layout directory of an Android project and are inflated at runtime to create the actual views. They allow developers to separate the UI design from the code logic and support multiple device configurations and languages through resource qualifiers.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Basic",
    "subCategoryId": 11
  },
  {
    "id": 121,
    "question": "What is a Context Menu in Android?",
    "answer": "A Context Menu in Android is a floating menu that appears when the user performs a long press on a UI element, such as a button or list item. It provides a set of actions or options related to the selected item. Context menus are commonly used to offer additional functionality or operations on specific items, such as deleting, sharing, or editing. They can be defined in XML or created programmatically using the registerForContextMenu() and onCreateContextMenu() methods.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Basic",
    "subCategoryId": 11
  },
  {
    "id": 122,
    "question": "What is a ViewPager in Android?",
    "answer": "A ViewPager is a UI component in Android that allows the user to swipe horizontally to navigate between multiple pages, typically represented as fragments or views. It is commonly used to create screens with tabs or slide-based content. The ViewPager automatically handles the animation and layout of the pages and provides a smooth scrolling experience. It is often combined with TabLayout to create a tabbed interface with swipeable content.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Basic",
    "subCategoryId": 11
  },
  {
    "id": 123,
    "question": "What is an AlertDialog in Android?",
    "answer": "An AlertDialog is a modal dialog box in Android that displays a message, prompt, or set of options to the user. It is typically used to show important information, ask for confirmation, or prompt the user for input. AlertDialogs can have customizable titles, messages, buttons, and a variety of predefined styles. They are created and displayed using the AlertDialog.Builder class and can handle user interactions through listeners or callbacks.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Basic",
    "subCategoryId": 11
  },
  {
    "id": 124,
    "question": "What is ProGuard in Android?",
    "answer": "ProGuard is a tool in Android used for code shrinking, obfuscation, and optimization. It reduces the size of the APK by removing unused code, renaming classes, fields, and methods to make the code harder to understand and reverse engineer. ProGuard can significantly reduce the APK size and improve the app's performance. It is commonly used in release builds to protect sensitive information, prevent unauthorized code analysis, and improve the app's security.",
    "difficulty": "Unknown",
    "topCategory": "Android",
    "topCategoryId": 1,
    "subCategory": "Basic",
    "subCategoryId": 11
  }
]
