[
  {
    "id": 49,
    "question": "Describe Singleton design pattern",
    "answer": "The Singleton design pattern is a creational design pattern that restricts the instantiation of a class to a single instance and provides a global point of access to that instance. It ensures that only one instance of the class exists throughout the application and provides a way to access that instance globally. The Singleton pattern is commonly used in scenarios where a single object needs to coordinate actions across the system.",
    "difficulty": "Easy",
    "topCategory": "Design Patterns",
    "topCategoryId": 21,
    "subCategory": "Unknown",
    "subCategoryId": 0
  },
  {
    "id": 208,
    "question": "State design pattern",
    "answer": "The State design pattern is a behavioral design pattern that allows an object to change its behavior when its internal state changes. It enables an object to alter its behavior when the internal state changes, without changing its class. The State pattern is particularly useful in scenarios where an object's behavior varies based on its internal state, and the object needs to transition between different states smoothly. By using the State pattern, the complexity of state transitions is encapsulated within the state classes, promoting clean code and making it easier to add new states or modify existing ones.",
    "difficulty": "Unknown",
    "topCategory": "Design Patterns",
    "topCategoryId": 21,
    "subCategory": "Unknown",
    "subCategoryId": 0
  },
  {
    "id": 209,
    "question": "Decorator design pattern",
    "answer": "The Decorator design pattern is a structural design pattern that allows behavior to be added to an individual object, either statically or dynamically, without affecting the behavior of other objects from the same class. It is used to extend the functionality of objects at runtime by wrapping them with additional behavior. The Decorator pattern promotes the principle of Open/Closed, as it allows new behavior to be added to objects without modifying their code. This pattern is particularly useful when you have a set of classes with many possible combinations of features, and you want to avoid a class explosion.",
    "difficulty": "Unknown",
    "topCategory": "Design Patterns",
    "topCategoryId": 21,
    "subCategory": "Unknown",
    "subCategoryId": 0
  },
  {
    "id": 210,
    "question": "MVP vs MVVM",
    "answer": "MVP (Model-View-Presenter) and MVVM (Model-View-ViewModel) are two common architectural patterns used in Android development:\n\nMVP:\n- Model-View-Presenter separates the responsibilities of an Android component into three parts: Model, View, and Presenter.\n- Model represents the data and business logic.\n- View displays the data and notifies the Presenter of user actions.\n- Presenter acts as an intermediary between the Model and View, handling user interactions and updating the View based on the data from the Model.\n\nMVVM:\n- Model-View-ViewModel is a more recent pattern and has become popular due to its data-binding capabilities in frameworks like Android's Data Binding Library and Jetpack Compose.\n- Model represents the data and business logic.\n- View is responsible for displaying data and user interface elements.\n- ViewModel is a mediator between the Model and View, exposing data and behaviors to the View via data-binding.\n\nBoth patterns aim to separate concerns, making the code more maintainable and testable. The choice between MVP and MVVM often depends on the specific needs of the project and the development team's preferences.",
    "difficulty": "Unknown",
    "topCategory": "Design Patterns",
    "topCategoryId": 21,
    "subCategory": "Unknown",
    "subCategoryId": 0
  },
  {
    "id": 211,
    "question": "Facade design pattern",
    "answer": "The Facade design pattern is a structural design pattern that provides a simplified interface to a complex system of classes, libraries, or APIs. It acts as a unified and higher-level interface, making it easier for clients to interact with the subsystem. By using the Facade pattern, clients can access the functionalities of a complex system without needing to understand its internal complexities. The Facade pattern promotes loose coupling and encapsulation, as clients only interact with the facade interface without directly accessing the underlying components.",
    "difficulty": "Unknown",
    "topCategory": "Design Patterns",
    "topCategoryId": 21,
    "subCategory": "Unknown",
    "subCategoryId": 0
  },
  {
    "id": 212,
    "question": "Types of design patterns with examples",
    "answer": "Design patterns are typically categorized into three main types:\n\n1. Creational Design Patterns: These patterns focus on object creation mechanisms and provide ways to create objects in a manner suitable for the situation.\nExample: Singleton, Factory Method, Builder.\n\n2. Structural Design Patterns: These patterns deal with the composition of classes and objects to form larger structures.\nExample: Adapter, Decorator, Facade.\n\n3. Behavioral Design Patterns: These patterns focus on communication and interaction between objects.\nExample: Observer, Strategy, Command.\n\nEach type of design pattern addresses specific design problems and helps in achieving various software design goals, such as flexibility, extensibility, and maintainability.",
    "difficulty": "Unknown",
    "topCategory": "Design Patterns",
    "topCategoryId": 21,
    "subCategory": "Unknown",
    "subCategoryId": 0
  },
  {
    "id": 213,
    "question": "Strategy design pattern",
    "answer": "The Strategy design pattern is a behavioral design pattern that allows selecting an algorithm at runtime from a family of interchangeable algorithms. It enables clients to choose from multiple algorithms dynamically without affecting the client code. In this pattern, the algorithms are encapsulated in separate classes that implement a common interface. The client code can switch between different strategies by setting a specific strategy at runtime. The Strategy pattern promotes flexibility and avoids code duplication by separating the algorithm from the client code.",
    "difficulty": "Unknown",
    "topCategory": "Design Patterns",
    "topCategoryId": 21,
    "subCategory": "Unknown",
    "subCategoryId": 0
  },
  {
    "id": 214,
    "question": "Most popular design patterns in Android",
    "answer": "Several design patterns are widely used in Android development:\n\n1. Singleton: Used to ensure that a class has only one instance and provides a global point of access to that instance.\n\n2. Observer: Used to implement event handling and communication between components.\n\n3. Adapter: Used to convert one interface into another, allowing incompatible classes to work together.\n\n4. Builder: Used to construct complex objects step by step.\n\n5. Factory Method: Used to create objects without specifying the exact class of the object that will be created.\n\n6. MVP (Model-View-Presenter) and MVVM (Model-View-ViewModel): Architectural patterns used to separate concerns and make the code more maintainable.\n\nThese patterns are just a few examples of how design patterns can be applied to solve common problems in Android development. Understanding and utilizing these patterns can lead to more efficient and maintainable Android applications.",
    "difficulty": "Unknown",
    "topCategory": "Design Patterns",
    "topCategoryId": 21,
    "subCategory": "Unknown",
    "subCategoryId": 0
  },
  {
    "id": 316,
    "question": "Factory design pattern",
    "answer": "The Factory design pattern is a creational pattern that provides an interface for creating objects in a super class but allows subclasses to alter the type of objects that will be created. It promotes loose coupling by eliminating the need for the client code to specify the exact class of the object that will be created. Instead, the factory method determines the class of the object to be instantiated based on certain conditions.\n\nThe Factory pattern is useful when there is a need to create multiple objects of similar types or when the exact class of the object to be created can vary depending on the application's logic.",
    "difficulty": "Unknown",
    "topCategory": "Design Patterns",
    "topCategoryId": 21,
    "subCategory": "Unknown",
    "subCategoryId": 0
  },
  {
    "id": 317,
    "question": "Builder design pattern",
    "answer": "The Builder design pattern is a creational pattern that separates the construction of a complex object from its representation. It allows the same construction process to create different representations of an object. The Builder pattern involves defining a separate Builder class that constructs the complex object step by step, and a Director class that controls the construction process.\n\nThe Builder pattern is useful when an object requires a large number of configuration options or parameters during construction, and having multiple constructors with different combinations of parameters would be cumbersome. By using the Builder pattern, the client code can construct objects with a clear and readable syntax.",
    "difficulty": "Unknown",
    "topCategory": "Design Patterns",
    "topCategoryId": 21,
    "subCategory": "Unknown",
    "subCategoryId": 0
  },
  {
    "id": 318,
    "question": "Factory vs builder design pattern",
    "answer": "The Factory and Builder design patterns are both creational patterns, but they serve different purposes:\n\n1. Factory Pattern: The Factory pattern is used to create objects of similar types, where the exact class of the object to be created is determined at runtime. It provides an interface for creating objects in a super class and allows subclasses to change the type of objects that will be created.\n\n2. Builder Pattern: The Builder pattern is used to construct complex objects step by step, separating the construction from the representation. It allows the same construction process to create different representations of the object.\n\nIn summary, the Factory pattern focuses on creating objects of similar types, while the Builder pattern focuses on constructing complex objects with flexible configuration options.",
    "difficulty": "Unknown",
    "topCategory": "Design Patterns",
    "topCategoryId": 21,
    "subCategory": "Unknown",
    "subCategoryId": 0
  },
  {
    "id": 319,
    "question": "Facade design pattern",
    "answer": "The Facade design pattern is a structural pattern that provides a simple and unified interface to a complex system or a set of interfaces in a subsystem. It acts as a high-level interface that makes the underlying system easier to use and understand for client code.\n\nThe main purpose of the Facade pattern is to provide a single entry point to access a set of functionalities or services. It hides the complexities of the subsystem from the client, simplifying the interactions and reducing dependencies between the client and the subsystem.\n\nThe Facade pattern is useful when there is a need to provide a simplified interface to a complex system or to reduce the coupling between the client and the subsystem.",
    "difficulty": "Unknown",
    "topCategory": "Design Patterns",
    "topCategoryId": 21,
    "subCategory": "Unknown",
    "subCategoryId": 0
  },
  {
    "id": 320,
    "question": "Observer design pattern",
    "answer": "The Observer design pattern is a behavioral pattern that establishes a one-to-many dependency between objects, where multiple observers (subscribers) are notified automatically of any state changes that occur in a subject (publisher).\n\nIn the Observer pattern, the subject maintains a list of its dependents (observers) and notifies them of any changes in its state. When the state of the subject changes, it broadcasts the notification to all registered observers, and each observer can react to the update accordingly.\n\nThe Observer pattern is useful in scenarios where there is a need for loose coupling between the subject and its observers, allowing for easy extensibility and flexibility in adding or removing observers.",
    "difficulty": "Unknown",
    "topCategory": "Design Patterns",
    "topCategoryId": 21,
    "subCategory": "Unknown",
    "subCategoryId": 0
  }
]